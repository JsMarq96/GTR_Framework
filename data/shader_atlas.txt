//example of some shaders compiled
// Basic /  Base shaders
flat basic.vs flat.fs
skybox basic.vs skybox.fs
shadow_flat basic.vs shadow_flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
probe basic.vs probe.fs
ref_probe basic.vs ref_probe.fs
// Phong
multi_phong basic.vs multi_phong.fs
single_phong basic.vs single_phong.fs
// Forward - PBR
forward_singlepass_pbr basic.vs forward_singlepass_pbr.fs
// Deferred -PBR
deferred_plane_opaque basic.vs deferred_plain_opaque.fs
deferred_plane_traslucent basic.vs deferred_plain_traslucent.fs
deferred_lightpass basic.vs deferred_lightpass.fs
deferred_pass quad.vs deferred_pass.fs
deferred_world_pos quad.vs deferred_world_pos.fs
deferred_decals basic.vs deferred_decals.fs
// Render Passes & Effects
ao_pass quad.vs ao_pass.fs
uncharted_tonemapper quad.vs uncharted_tonemapping_pass.fs
perception_tonemapper quad_max_lum.vs perception_tonemapping_pass.fs
volumetric quad.vs volumetric.fs
comp_volumetric quad.vs comp_volumetric.fs
threshold_bloom quad.vs threshold_bloom.fs
bloom quad.vs bloom.fs
// Tools
compute_lum quad.vs compute_lum.fs
blur quad.vs blur.fs
compute_max_and_avg_lum quad.vs compute_max_and_avg_lum.fs

\sphere_harmonics
const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;

void SHCosineLobe(in vec3 dir, out float sphere_weight[9]) //SH9
{
	// Band 0
	sphere_weight[0] = 0.282095 * CosineA0;
	// Band 1
	sphere_weight[1] = 0.488603 * dir.y * CosineA1; 
	sphere_weight[2] = 0.488603 * dir.z * CosineA1;
	sphere_weight[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sphere_weight[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sphere_weight[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sphere_weight[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sphere_weight[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sphere_weight[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradiance(in vec3 normal, in vec3 sphere_colors[9])
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	float shCosine[9];
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += shCosine[i] * sphere_colors[i];

	return irradiance;
}

\probe.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;

uniform vec3 u_sphere_coeffs[9];

out vec4 FragColor;
#include "sphere_harmonics"

void main()
{
	FragColor = vec4(ComputeSHIrradiance(normalize(v_normal), u_sphere_coeffs), 1.0);
}

\depth_functions
const vec3 TILES_SIZES[MAX_SHADOWS] = vec3[](
	vec3(0.0, 0.5, 0.5), // Tile 0
	vec3(0.0, 0.0, 0.5), // 1
	vec3(0.5, 0.0, 0.5), // 2
	vec3(0.5, 0.25, 0.25), // 3
	vec3(0.75, 0.0, 0.25), // 4
	vec3(0.75, 0.25, 0.25), // 5
	vec3(0.75, 0.5, 0.25) // 6
);

float get_shadow_component(int light_id, vec3 world_pos) {
	vec4 frag_shadow_pos = u_shadow_vp[light_id] * vec4(world_pos, 1.0);
	//vec4 frag_shadow_pos =  vec4(v_world_position, 1.0);
	vec2 frag_shadow_uv = ((frag_shadow_pos.xy / frag_shadow_pos.w) * 0.5) + vec2(0.5); // ??

	if (frag_shadow_uv.x < 0.0 && frag_shadow_uv.x > 1.0 && frag_shadow_uv.y < 0.0 && frag_shadow_uv.y > 1.0) {
		return 0.0;
	}

	frag_shadow_uv.xy = TILES_SIZES[light_id].xy + (frag_shadow_uv.xy * TILES_SIZES[light_id].z);

	float frag_depth = (((frag_shadow_pos.z - u_shadow_bias) / frag_shadow_pos.w) * 0.5) + 0.5;
	float shadow_map_depth = texture(u_shadow_map, frag_shadow_uv).x;

	float shadow_compoment = 1.0f;
	if (shadow_map_depth < frag_depth && (frag_depth > 0.0 && frag_depth < 1.0)) {
		shadow_compoment = 0.0;
	}

	return shadow_compoment;
}

\normal_functions

mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {
  // get edge vectors of the pixel triangle
  vec3 dp1 = dFdx(p);
  vec3 dp2 = dFdy(p);
  vec2 duv1 = dFdx(uv);
  vec2 duv2 = dFdy(uv);

  // solve the linear system
  vec3 dp2perp = cross(dp2, N);
  vec3 dp1perp = cross(N, dp1);
  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

  // construct a scale-invariant frame 
  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));
  return mat3(normalize(T * invmax), normalize(B * invmax), N);
}

vec3 perturbNormal(vec3 N, vec3 world_pos, vec2 uv) {
	vec3 normal_pixel = texture2D(u_normal_tex, uv).xyz;
	// from 1 - 0 range to -1 - 1 range
	normal_pixel = normal_pixel * 255.0/127.0 - 128.0/127.0;
	mat3 TBN = cotangentFrame(N, world_pos, uv);
	return normalize(TBN * normal_pixel);
}

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;
out mat4 v_viewprojection_inv;
out mat4 v_model_inv;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	v_viewprojection_inv = inverse(u_viewprojection);

	v_model_inv = inverse(u_model);

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
uniform mat4 u_viewprojection;
out vec2 v_uv;
out mat4 v_viewprojection_inv;

void main()
{	
	v_uv = a_coord;
	v_viewprojection_inv = inverse(u_viewprojection);
	gl_Position = vec4( a_vertex, 1.0 );
}
\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}

\shadow_flat.fs

#version 330 core

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_alpha_cutoff;

in vec2 v_uv;

out vec4 FragColor;

void main()
{
	if (texture(u_texture, v_uv).a < u_alpha_cutoff) {
		discard;
	}
	FragColor = u_color;
}

\multi_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;
uniform vec3 u_emmisive_factor;

uniform float u_time;
uniform float u_alpha_cutoff;

// Light data
uniform vec3 u_ambient_light;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform int u_light_type;
uniform float u_light_max_dist;
uniform float u_light_intensities;
uniform int u_num_lights;

// Spot light uniforms
uniform float u_light_cone_angle;
uniform float u_light_cone_decay;
uniform vec3 u_light_direction;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;
uniform int u_light_id;

out vec4 FragColor;

#include "depth_functions"

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	float shadow_compoment = get_shadow_component(u_light_id, v_world_position);

	if (shadow_compoment == 0) {
		FragColor = vec4(color.rgb * u_ambient_light, 1.0);
		return;
	}

	vec3 L = vec3(0.0);
	vec3 D = normalize(u_light_direction);

	if (u_light_type == 1) { // Point light
		L = normalize(u_light_direction);
	} else {
		L = normalize(u_light_pos - v_world_position);
	}
		
	float n_dot_l = max(dot(L, N), 0.0);
	float l_dot_d = dot(D, L);

	// Quadratic light attenuation
	float light_attenuation = u_light_max_dist - length(u_light_pos - v_world_position);
	light_attenuation = max(light_attenuation / u_light_max_dist, 0.0); 
	light_attenuation *= light_attenuation;

	if (u_light_type == 2) { // Spot light
		if (l_dot_d >= u_light_cone_angle) {
			// If the fragment to light direction is inside the angle of the spotlight
			light_component += (pow(l_dot_d, u_light_cone_decay) * n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
		}
	} else { // For directional & spotlight
		light_component += (n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
	}
	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	color.rgb = color.rgb * (light_component + u_ambient_light + emmisive_comp) * occlusion_comp;

	FragColor = color;
}

\single_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

uniform float u_time;
uniform float u_alpha_cutoff;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

// Light data
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform int u_light_type[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_LIGHT];
uniform float u_shadow_bias;

// Spot light uniforms
uniform float u_light_cone_angle[MAX_LIGHT];
uniform float u_light_cone_decay[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];

out vec4 FragColor;
#include "depth_functions"

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	vec3 light_component = vec3(0.0);

	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = get_shadow_component(u_light_shadow_id[i], v_world_position);

		if (shadow_compoment == 0) {
			continue;
		}

		vec3 L = vec3(0.0);
		vec3 D = normalize(u_light_direction[i]);

		if (u_light_type[i] == 1) { // Directional light
			L = normalize(u_light_direction[i]);
		} else {
			L = normalize(u_light_pos[i] - v_world_position);
		}
		
		float n_dot_l = max(dot(L, N), 0.0);
		float l_dot_d = dot(D, L);

		// Quadratic light attenuation
		float light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - v_world_position);
		light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
		light_attenuation *= light_attenuation;

		if (u_light_type[i] == 2) { // Spot light
			if (l_dot_d >= u_light_cone_angle[i]) {
				// If the fragment to light direction is inside the angle of the spotlight
				light_component += (pow(l_dot_d, u_light_cone_decay[i]) * n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
			}
		} else if (u_light_type[i] == 1) { 
			light_component += (n_dot_l * u_light_color[i]) * u_light_intensities[i];
		} else { // For directional & spotlight
			light_component += (n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
		}
	}

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	FragColor = vec4(color.rgb * ((light_component + emmisive_comp) + (occlusion_comp * u_ambient_light)), 1.0);
}

\deferred_plain_opaque.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;
uniform vec3 u_emmisive_factor;
uniform int u_material_type;

uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 o_frag_albedo;
layout(location = 1) out vec4 o_frag_normal;
layout(location = 2) out vec4 o_frag_materials;
layout(location = 3) out vec4 o_emmisive_materials;

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb + u_emmisive_factor;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	o_frag_albedo = color;
	vec3 text_N = texture( u_normal_tex, v_uv).rgb;
	vec3 N = vec3(0.0);
	if(length(text_N.rgb) == 0.0) {
		N = normalize(v_normal);
	} else {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	o_frag_normal = vec4(N * 0.5 + vec3(0.5), occlusion_comp);
	vec4 mats = texture( u_met_rough_tex, v_uv);
	if (u_material_type == 0) {
		o_frag_materials = vec4(mats.r, mats.g, 0.0, 0.0);
	} else {
		o_frag_materials = vec4(mats.g, mats.b, 0.0, 0.0);
	}
	o_emmisive_materials = vec4(emmisive_comp, 1.0);
}

\deferred_plain_traslucent.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;
uniform vec3 u_emmisive_factor;
uniform int u_material_type;

uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 o_frag_albedo;
layout(location = 1) out vec4 o_frag_normal;
layout(location = 2) out vec4 o_frag_materials;
layout(location = 3) out vec4 o_emmisive_materials;

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb + u_emmisive_factor;

	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	o_frag_albedo = color;
	vec3 text_N = texture( u_normal_tex, v_uv).rgb;
	if(length(text_N.rgb) == 0.0) {
		o_frag_normal = vec4(normalize(v_normal), occlusion_comp);
	} else {
		o_frag_normal = vec4(perturbNormal(normalize(v_normal), v_world_position, v_uv), occlusion_comp);
	}
	
	vec4 mats = texture( u_met_rough_tex, v_uv);
	if (u_material_type == 0) {
		o_frag_materials = vec4(mats.r, mats.g, 0.0, 0.0);
	} else {
		o_frag_materials = vec4(mats.g, mats.b, 0.0, 0.0);
	}
	o_emmisive_materials = vec4(emmisive_comp, 1.0);
}

\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
uniform int u_linearize;
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	if (u_linearize == 1.0) {
		color = z;
	}
	FragColor = vec4(color);
}

\deferred_world_pos.fs

#version 330 core
uniform sampler2D u_depth_tex;

in vec2 u_camera_nearfar;
in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

vec3 get_world_position_from_depth(const in vec2 uv) {
	float d = texture2D(u_depth_tex, uv).x;	
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

void main()
{
	vec3 pos = get_world_position_from_depth(v_uv);
	FragColor = vec4(pos, 1.0);
}

\brdf
float distribution_GGX(const in sFragData data, const in sFragVects vectors) {
	float alpha_squared = data.alpha * data.alpha;

	float f = ((vectors.n_dot_h * vectors.n_dot_h) * (alpha_squared - 1.0)) + 1.0;
	return alpha_squared / ((PI * f * f));
}

vec3 fresnel_schlick(const in float angle, const in vec3 f0, const in float roughness) {
	float f = pow(1.0 - angle, 5.0);
	return f0 + (vec3(1.0 - roughness) - f0) * f;
}

float GGX(const in float n_dot_v, const in float k) {
	return n_dot_v / (n_dot_v * (1.0 - k) + k);
}

float geometry_Smith(const in sFragData data, const in sFragVects vectors) {
	float k = pow(data.roughness + 1.0, 2.0) / 8.0;
	return GGX(vectors.n_dot_l, k) * GGX(vectors.n_dot_v, k);
}

vec3 specular_BRDF(const in sFragData data, const in sFragVects vectors) {
	float D = distribution_GGX(data, vectors);

	vec3 F = fresnel_schlick(vectors.n_dot_h, data.f0, data.roughness);

	float G = geometry_Smith(data, vectors);

	float normalization = (4.0 * vectors.n_dot_l * vectors.n_dot_v) + 0.001;

	return vec3(D * F * G) / normalization;
}

\pbr 

#include "brdf"

vec3 get_pbr_color(const in sFragData data, const in sFragVects vects) {
	vec3 diffuse_color = mix(data.albedo, vec3(0.0), data.metalness);

	vec3 specular = specular_BRDF(data, vects);
	vec3 diffuse = data.occlusion * diffuse_color / PI; // Lambertian BRDF cuz cheap

	return ((specular + diffuse) * vects.attenuation);
}

\hdr_tonemapping

vec3 de_gamma(const in vec3 color) {
	return pow(color, vec3(2.2));
}

vec3 gamma(const in vec3 color) {
	return pow(color, vec3(1.0/2.2));
}

\frag_data

struct sFragData {
	// Material
	float roughness;
	float alpha;
	float metalness;
	vec3 f0;

	vec3 albedo;
	vec3 emmisive;

	float occlusion;

	vec3 normal;

	// Position
	vec3 world_pos;

	float depth;

	vec2 uv;
};

struct sFragVects {
	vec3 r;
	vec3 l;
	float n_dot_v;
	float n_dot_h;
	float n_dot_l;
	float l_dot_d;
	float l_dot_h;
	float v_dot_h;
	float attenuation;
};

\deferred_fragment_data
sFragVects getVectsOfFragment(const in sFragData mat, const in vec3 light_pos, const in vec3 light_direction, const in float light_max_dist, const in int light_type) {
	sFragVects vects;

	if (light_type == 1) { // Directional light
		vects.l = normalize(light_direction);
		vects.attenuation = 1.0; // No atenuation for the directional/sun/moon light
	} else {
		vects.l = normalize(light_pos - mat.world_pos);
		vects.attenuation = light_max_dist - length(mat.world_pos - light_pos);
		vects.attenuation = max(vects.attenuation / light_max_dist, 0.0); 
		vects.attenuation *= vects.attenuation;
	}


	vec3 D = normalize(light_direction);
	vec3 v = normalize(u_camera_position - mat.world_pos);
	vec3 half_v = normalize(v + vects.l);

	vects.r = reflect(v, normalize(mat.normal));

	vects.l_dot_d = clamp(dot(D, vects.l), 0.0001, 1.0);
	vects.l_dot_h = clamp(dot(half_v, vects.l), 0.0001, 1.0);

	vects.n_dot_v = clamp(dot(mat.normal, v), 0.0001, 1.0);
	vects.n_dot_h = clamp(dot(mat.normal, half_v), 0.0001, 1.0);
	vects.n_dot_l = clamp(dot(mat.normal, vects.l), 0.0001, 1.0);

	return vects;
}

vec3 get_world_position_from_depth(const in vec2 uv) {
	float d = texture2D(u_depth_tex, uv).x;	
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

#include "hdr_tonemapping"

sFragData getDataOfFragment(const in vec2 uv) {
	sFragData mat;

	vec4 mrt = texture(u_met_rough_tex, uv);
	mat.roughness = mrt.g;
	mat.metalness = mrt.r;

	mat.albedo = de_gamma(texture(u_albedo_tex, uv).rgb);

	vec4 norm_occ = texture(u_normal_occ_tex, uv);
	mat.normal = normalize(norm_occ.rgb * 2.0 - 1.0);
	mat.occlusion = norm_occ.a;

	mat.world_pos = get_world_position_from_depth(uv);

	mat.f0 = mix(vec3(0.001), mat.albedo, mat.metalness);
	mat.alpha = mat.roughness * mat.roughness;

	mat.uv = uv;

	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_depth_tex, uv).x;
	mat.depth = n * (z + 1.0) / (f + n - z * (f - n));

	return mat;
}


\forward_fragment_data

sFragVects getVectsOfFragment(const in sFragData mat, const in vec3 light_pos, const in vec3 light_direction, const in float light_max_dist, const in int light_type) {
	sFragVects vects;

	if (light_type == 1) { // Directional light
		vects.l = normalize(light_direction);
		vects.attenuation = 1.0; // No atenuation for the directional/sun/moon light
	} else {
		vects.l = normalize(light_pos - mat.world_pos);
		vects.attenuation = light_max_dist - length(mat.world_pos - light_pos);
		vects.attenuation = max(vects.attenuation / light_max_dist, 0.0); 
		vects.attenuation *= vects.attenuation;
	}
	
	vec3 D = normalize(light_direction);
	vec3 v = normalize(u_camera_position - mat.world_pos);
	vec3 half_v = normalize(v + vects.l);

	vects.r = reflect(v, normalize(mat.normal));

	vects.l_dot_d = clamp(dot(D, vects.l), 0.0001, 1.0);
	vects.l_dot_h = clamp(dot(half_v, vects.l), 0.0001, 1.0);

	vects.n_dot_v = clamp(dot(mat.normal, v), 0.0001, 1.0);
	vects.n_dot_h = clamp(dot(mat.normal, half_v), 0.0001, 1.0);
	vects.n_dot_l = clamp(dot(mat.normal, vects.l), 0.0001, 1.0);

	return vects;
}

#include "hdr_tonemapping"

sFragData getDataOfFragment(const in vec2 uv) {
	sFragData mat;

	vec4 mrt = texture(u_met_rough_tex, uv);
	mat.roughness = mrt.g;
	mat.metalness = mrt.r;

	mat.albedo = de_gamma(u_color.rgb * texture(u_texture, uv).rgb);

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}
	mat.normal = N;

	mat.emmisive =  de_gamma(texture( u_emmisive_tex, v_uv ).rgb) * u_emmisive_factor;
	mat.occlusion = min(texture( u_occlusion_tex, v_uv ).r, texture(u_ambient_occlusion_tex, v_uv).r);

	mat.world_pos = v_world_position;

	mat.f0 = mix(vec3(0.001), mat.albedo, mat.metalness);
	mat.alpha = mat.roughness * mat.roughness;

	mat.uv = uv;

	return mat;
}

\uncharted_tonemapping_pass.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_albedo_tex;

layout(location = 0) out vec4 o_color;

#include "hdr_tonemapping"

// Source http://filmicworlds.com/blog/filmic-tonemapping-operators/
const float A = 0.15;
const float B = 0.50;
const float C = 0.10;
const float D = 0.20;
const float E = 0.02;
const float F = 0.30;
const float W = 11.2;

vec3 Uncharted2TonemapPartial(vec3 x) {
   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

void main() {
	vec3 tonemapped_color = Uncharted2TonemapPartial(texture(u_albedo_tex, v_uv).rgb * 2.0);

	vec3 W = vec3(11.2f);
    vec3 white_scale = vec3(1.0f) / Uncharted2TonemapPartial(W);

	o_color = vec4(gamma(tonemapped_color * white_scale), 1.0);
}

\perception_tonemapping_pass.fs

#version 330 core

in vec2 v_uv;
in float v_max_lum;
in float v_avg_lum;
in float v_prev_avg_lum;

uniform sampler2D u_albedo_tex;

layout(location = 0) out vec4 o_color;

#include "hdr_tonemapping"

void main() {
	vec3 color = texture(u_albedo_tex, v_uv).rgb;

	// Extender Reinhart Lumainance
	// Source: https://64.github.io/tonemapping/
	// Get pixel puma
	//color /= v_prev_avg_lum;
	float old_luma = dot(color, vec3(0.2126, 0.7152, 0.0722));

	//float scalled_luma = (0.0005 / v_prev_avg_lum) * old_luma; // 0.005??
	float scalled_luma = old_luma;

	// Compute the new luminance (added a tiy bias por maximun luminosity of 0.0)
    	float new_luma = (scalled_luma * (1.0 + scalled_luma / ((v_max_lum * v_max_lum) + 0.001))) / (1.0 + scalled_luma);

	//new_luma /= v_prev_avg_lum;

	// Add change the luminance, by scalling
	color = color * (new_luma / old_luma);

	// Set a minimun luminance
	//color = max(color,vec3(0.001));
	o_color = vec4(gamma(color), 1.0);
}

\compute_lum.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_albedo_tex;

layout(location = 0) out vec4 o_lum;

void main() {
	vec3 rgb = texture(u_albedo_tex, v_uv).rgb; 
	float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
	//lum = 2.0 * lum;
 	o_lum = vec4(lum, lum, lum, 1.0);
}

\quad_max_lum.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;

uniform mat4 u_viewprojection;
uniform sampler2D u_max_avg_lum_tex;
uniform sampler2D u_max_avg_lum_prev_tex;

out vec2 v_uv;
out mat4 v_viewprojection_inv;
out float v_max_lum;
out float v_avg_lum;
out float v_prev_max_lum;
out float v_prev_avg_lum;

void main()
{	
	v_uv = a_coord;
	v_viewprojection_inv = inverse(u_viewprojection);

	// texture is sized 1,1 should not matter the uvs
	vec4  max_avg_lum = texture(u_max_avg_lum_tex, vec2(0.0, 0.0)).rgba;
	v_max_lum = max_avg_lum.r;
	v_avg_lum = max_avg_lum.g;

	vec4 max_avg_lum_prev = texture(u_max_avg_lum_prev_tex, vec2(0.5, 0.5)).rgba;
	v_prev_max_lum = max_avg_lum_prev.r;
	v_prev_avg_lum = max_avg_lum_prev.g;

	gl_Position = vec4( a_vertex, 1.0 );
}

\compute_max_and_avg_lum.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_tex;
uniform vec2 u_text_size;
uniform float u_write_to_swap;
uniform int u_lowest_mip_level;
uniform int u_is_first_frame;

layout(location = 0) out vec4 o_avg_max_swap1;
layout(location = 1) out vec4 o_avg_max_swap2;

#include "hdr_tonemapping"

void main() {
	float max_pixel = -10.0;
	float avg_pixel = 0.0;
	
	// Get the lowest posible mip of size (1,1) for the avg luma
 	avg_pixel = textureLod(u_tex, vec2(0.5, 0.5), u_lowest_mip_level).r; 

	// Get medium mip comuting the maximum
	int mip_level = int(u_lowest_mip_level / 2);	
	vec2 mip_size = textureSize(u_tex, mip_level);
	for(int x = 0; x < mip_size.x ; x++) {
		for(int y = 0; y < mip_size.y ; y++) {
			vec2 uv = vec2(x,y) / mip_size;
			// No need to convert since the source is in luma
			float r = textureLod(u_tex, uv, mip_level).r;
			max_pixel = max(r, max_pixel);
		}
	}

	max_pixel = max(0.0, max_pixel);

	if (u_is_first_frame == 1) {
		if (u_write_to_swap == 0) {
			o_avg_max_swap1 = vec4(max_pixel, avg_pixel, 0.0, 1.0);
		} else {
			o_avg_max_swap1 = vec4(max_pixel, avg_pixel, 0.0, 1.0);
		}
	} else {
		o_avg_max_swap1 = vec4(max_pixel, avg_pixel, 0.0, 1.0);
		o_avg_max_swap1 = vec4(max_pixel, avg_pixel, 0.0, 1.0);
	}
	
}

\ao_pass.fs

#version 330 core

const float PI = 3.14159226;

uniform vec2 u_camera_nearfar;
uniform vec3 u_camera_position;

uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_depth_tex;
uniform sampler2D u_noise_tex;

uniform float u_ao_radius;

uniform vec2 u_noise_scale;

uniform vec2 u_near_far;

uniform mat4 u_viewprojection;
uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_inv_projection;

const int SAMPLE_SIZE = 64;
uniform vec3 u_random_point[SAMPLE_SIZE];

in vec2 v_uv;
in mat4 v_viewprojection_inv;

layout(location = 0) out vec3 o_frag_ao;


vec3 get_view_position_from_depth(vec2 uv) {
	float d = texture(u_depth_tex, uv).r;
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = u_inv_projection * clip;

	return world_pos.xyz / world_pos.w;
}

void main() {
	float sample_depth = texture(u_depth_tex, v_uv).r;	

	// Discard if its too far away/ or is sky
	if (sample_depth >= 1.0) {
		o_frag_ao = vec3(1.0);
		return;
	}

	vec3 frag_view_pos = get_view_position_from_depth(v_uv);

	vec3 normal = texture(u_normal_occ_tex, v_uv).rgb;
	normal = normalize(normal.rgb * 2.0 - 1.0);

	// Set normal on viewspace
	normal = (u_view * vec4(normal, 0.0)).xyz;

	// Create TBN matrix
	vec3 random_vec = (vec3(texture(u_noise_tex, v_uv * u_noise_scale).xy * 2.0 - 1.0, 0.0));
	vec3 tangent = normalize(random_vec - normal * dot(random_vec, normal));
	vec3 bitangent = (cross(normal, tangent));
	mat3 rot_mat = mat3(tangent, bitangent, normal);

	float occlusion = 0.0;
	 vec3 rebuild_sample_pos = vec3(0.0);
	for(int i = 0; i < SAMPLE_SIZE; i++) {
		vec3 sample_point = (frag_view_pos) + (normalize(rot_mat * u_random_point[i]) * u_ao_radius);

		// Bias
		sample_point += normal * 0.5;

		vec4 sample_ndc = u_projection * vec4(sample_point, 1.0);
		vec2 sample_uv = (sample_ndc.xy / sample_ndc.w) * 0.5 + 0.5;

		if (sample_uv.x > 1.0 || sample_uv.y > 1.0 || sample_uv.x < 0.0 || sample_uv.y < 0.0) {
			continue;
		}

		rebuild_sample_pos = get_view_position_from_depth(sample_uv);

		if (rebuild_sample_pos.z >= sample_point.z && abs(rebuild_sample_pos.z - frag_view_pos.z) <= u_ao_radius) { 
			occlusion += 1.0;
		}

	}
	
	o_frag_ao = vec3(1.0 - (occlusion / float(SAMPLE_SIZE)));
	// Enhance contrast
	o_frag_ao = o_frag_ao * o_frag_ao;
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}


\blur.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_to_blur_tex;

layout(location = 0) out vec3 o_frag_blur;

const float filter_size = 10.0;

void main() {
	vec2 texel_size = 1.0 / vec2(textureSize(u_to_blur_tex, 0));
	vec3 result = vec3(0.0);

	for(int x = int(filter_size / -2); x < (filter_size / 2); x++) {
		for(int y = int(filter_size / -2); y < (filter_size / 2); y++) {
			vec2 offset = vec2(float(x), float(y)) * texel_size;
			result += texture(u_to_blur_tex, v_uv + offset).rgb;
		}
	}

	o_frag_blur = result / (filter_size * filter_size);
}

\irradiance

#include "sphere_harmonics"

vec3 compute_irr_with_grid_coord(const in vec3 grid_pos, const in vec3 normal) {
	float row = grid_pos.x + (grid_pos.y * u_irr_size.x) + (grid_pos.z * u_irr_size.x * u_irr_size.y);
	float row_uv = (row + 1.0) / (float(u_irr_probe_count) + 1.0);

	//return irr_grid_pos;
	//return vec3(row_uv, row_uv, row_uv) * 2.10;

	vec3 coeffs[9];
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; i++) {
		vec2 uv = vec2((float(i) + 0.5) * d_uvx, row_uv );
		coeffs[i] = texture(u_gi_probe_tex, uv).xyz;
	}

	return ComputeSHIrradiance(normalize(normal), coeffs) * 5.0;
}

vec3 compute_basic_irradiance(const in vec3 world_pos, const in vec3 normal) {
	// Convert to area position
	vec3 irr_local_pos = clamp(world_pos - u_irr_start + (normal * 0.5),  vec3(0.0), u_irr_size * u_irr_radius);

	// Convert to grid position
	vec3 irr_grid_pos = round(irr_local_pos / u_irr_radius);

	return compute_irr_with_grid_coord(irr_grid_pos, normal);
}

vec3 compute_irradiance(const in vec3 world_pos, const in vec3 normal) {
	// Convert to area position
	vec3 irr_local_pos = clamp(world_pos - u_irr_start + (normal * 0.5),  vec3(0.0), u_irr_size * u_irr_radius);

	// Convert to grid position
	vec3 grid_coords = irr_local_pos / u_irr_radius;
	vec3 local_indices = floor(grid_coords);
	vec3 factors = grid_coords - local_indices;
	
	/*
		Front View:
			Up (y+1)
			┌────┐
		Letf│    │Right (x+1)
			└────┘
			Down

		Side View:
			Up
			┌────┐
		Back│    │ Front (z+1)
			└────┘
			Down
	*/

	//local_indices points to Left,Bottom,Far
	vec3 indicesLBF = local_indices;
	//example for right bottom far index
	vec3 indicesRBF = local_indices;
	indicesRBF += vec3(1.0, 0.0, 0.0); //from left to right
	vec3 indicesLTF = local_indices;
	indicesLTF += vec3(0.0, 1.0, 0.0);
	vec3 indicesRTF = local_indices;
	indicesRTF += vec3(1.0, 1.0, 0.0);
	vec3 indicesLBN = local_indices;
	indicesLBN += vec3(0.0, 0.0, 1.0);
	vec3 indicesRBN = local_indices;
	indicesRBN += vec3(1.0, 0.0, 1.0);
	vec3 indicesLTN = local_indices;
	indicesLTN += vec3(0.0, 1.0, 1.0);
	vec3 indicesRTN = local_indices;
	indicesRTN += vec3(1.0, 1.0, 1.0);

	//compute irradiance for every corner
	vec3 irrLBF = compute_irr_with_grid_coord( indicesLBF, normal );
	vec3 irrRBF = compute_irr_with_grid_coord( indicesRBF, normal );
	vec3 irrLTF = compute_irr_with_grid_coord( indicesLTF, normal );
	vec3 irrRTF = compute_irr_with_grid_coord( indicesRTF, normal );
	vec3 irrLBN = compute_irr_with_grid_coord( indicesLBN, normal );
	vec3 irrRBN = compute_irr_with_grid_coord( indicesRBN, normal );
	vec3 irrLTN = compute_irr_with_grid_coord( indicesLTN, normal );
	vec3 irrRTN = compute_irr_with_grid_coord( indicesRTN, normal );

	vec3 irrTF = mix( irrLTF, irrRTF, factors.x );
	vec3 irrBF = mix( irrLBF, irrRBF, factors.x );
	vec3 irrTN = mix( irrLTN, irrRTN, factors.x );
	vec3 irrBN = mix( irrLBN, irrRBN, factors.x );

	vec3 irrT = mix( irrTF, irrTN, factors.z );
	vec3 irrB = mix( irrBF, irrBN, factors.z );

	vec3 irr = mix( irrB, irrT, factors.y );

	return irr;
	//return int_vals;

	//return mix(irrU, irrD, 1.0 - int_vals.y);
}

\forward_singlepass_pbr.fs

#version 330 core

const float PI = 3.14159226;

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

uniform float u_time;
uniform float u_alpha_cutoff;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;
uniform sampler2D u_ambient_occlusion_tex;
uniform sampler2D u_gi_probe_tex;
uniform vec3 u_emmisive_factor;
uniform samplerCube u_skybox_texture;

// GI / Irradiance data
uniform vec3 u_irr_start;
uniform vec3 u_irr_size;
uniform float u_irr_radius;
uniform vec2 u_irr_tex_size;
uniform int u_irr_probe_count;
uniform int u_use_irradiance;
uniform vec3 u_irr_end;

uniform vec3 u_camera_position;

// Light data
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform int u_light_type[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_LIGHT];
uniform float u_shadow_bias;

// Spot light uniforms
uniform float u_light_cone_angle[MAX_LIGHT];
uniform float u_light_cone_decay[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];

out vec4 FragColor;
#include "depth_functions"
#include "normal_functions"
#include "frag_data"
#include "forward_fragment_data"
#include "pbr"
#include "irradiance"


void main()
{
	vec4 color = texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;
	// Load fragment
	sFragData frag_data = getDataOfFragment(v_uv);

	vec3 ambient = u_ambient_light;
	if (u_use_irradiance == 1) {
		ambient = max(compute_irradiance(v_world_position, frag_data.normal), vec3(0.0));
	}

	//FragColor = vec4(ambient, 1.0); return;

	vec3 final_color = frag_data.albedo * (frag_data.occlusion * ambient);
	final_color.rgb += de_gamma(texture(u_emmisive_tex, v_uv).rgb) + u_emmisive_factor;
	vec3 light_component = vec3(0.0);
	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = 1.0;

		if (u_light_type[i] != 0) { // Calculate if its in shadow if its not a point-light
			shadow_compoment = get_shadow_component(u_light_shadow_id[i], frag_data.world_pos);
		}

		if (shadow_compoment == 0) {
			continue;
		}

		sFragVects light_vects = getVectsOfFragment(frag_data, u_light_pos[i], u_light_direction[i], u_light_max_dist[i], u_light_type[i]);

		// Quadratic light attenuation
		float light_attenuation = 1.0;

		if (u_light_type[i] != 1) {
			light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - v_world_position);
			light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
			light_attenuation *= light_attenuation;
		}

		if (u_light_type[i] == 2) { // Spot light
			if (light_vects.l_dot_d >= u_light_cone_angle[i]) {
				// If the fragment to light direction is inside the angle of the spotlight
				light_component = (pow(light_vects.l_dot_d, u_light_cone_decay[i]) * light_vects.n_dot_l * de_gamma(u_light_color[i])) * u_light_intensities[i] * light_attenuation;
			}
		} else { // For point light
			light_component = (light_vects.n_dot_l * de_gamma(u_light_color[i])) * u_light_intensities[i] * light_attenuation;
		}
		final_color += light_component * get_pbr_color(frag_data, light_vects);
	}

	// IBL
	vec3 v = normalize(u_camera_position - v_world_position);
	vec3 r = reflect(v, normalize(frag_data.normal));
	float n_dot_v = clamp(dot(frag_data.normal, v), 0.0001, 1.0);
	vec3 specular_sample = de_gamma(textureLod(u_skybox_texture, r, frag_data.roughness * 10.0).rgb);
	vec3 fresnel_IBL = fresnel_schlick(n_dot_v, specular_sample, frag_data.metalness);
	
	vec3 IBL = specular_sample * (frag_data.metalness * frag_data.roughness);

	FragColor = vec4(final_color + IBL, color.a);
}

\deferred_pass.fs

#version 330 core

const float PI = 3.14159226;

uniform vec2 u_camera_nearfar;
uniform vec3 u_camera_position;

// Light uniforms
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;
uniform int u_light_id;

uniform sampler2D u_albedo_tex;
uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_depth_tex;
uniform sampler2D u_ambient_occlusion_tex;
uniform samplerCube u_skybox_texture;
uniform samplerCube u_skybox_env_texture;

uniform vec3 u_emmisive_factor;

// GI / Irradiance data
uniform sampler2D u_gi_probe_tex;
uniform vec3 u_irr_start;
uniform vec3 u_irr_size;
uniform float u_irr_radius;
uniform vec2 u_irr_tex_size;
uniform int u_irr_probe_count;
uniform int u_use_irradiance;
uniform vec3 u_irr_end;

in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

#include "depth_functions"
#include "frag_data"
#include "deferred_fragment_data"
#include "pbr"
#include "irradiance"


void main()
{
	sFragData frag_data = getDataOfFragment(v_uv);

	float occlusion = min(frag_data.occlusion, texture(u_ambient_occlusion_tex, v_uv).r);

	vec3 ambient = u_ambient_light;
	vec3 skybox = vec3(0.0);

	if (frag_data.depth <= 1.0) {
		// Its an object
		if (u_use_irradiance == 1) {
			ambient = max(compute_irradiance(frag_data.world_pos, frag_data.normal), vec3(0.0));
		}
	} else {
		// Its the background/backplane, render the skybox
		vec3 V = normalize(frag_data.world_pos - u_camera_position);
		skybox = de_gamma(texture(u_skybox_env_texture, V).rgb);
	}

	//FragColor = vec4(ambient, 1.0); return;

	vec3 final_color = frag_data.albedo * (occlusion * (ambient));

	final_color += skybox;

	// Add emisivenes
	final_color += de_gamma(texture(u_emmisive_tex, v_uv).rgb) + u_emmisive_factor; 

	// Only for directiona lights
	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = get_shadow_component(u_light_shadow_id[i], frag_data.world_pos);

		if (shadow_compoment == 0) {
			continue;
		}


		sFragVects light_vects = getVectsOfFragment(frag_data, u_light_pos[i], u_light_direction[i], u_light_max_dist[i], 1);

		vec3 color = get_pbr_color(frag_data, light_vects);
		
		vec3 light_component = (light_vects.n_dot_l * de_gamma(u_light_color[i])) * u_light_intensities[i];

		final_color += color * light_component;
	}

	// IBL
	vec3 v = normalize(u_camera_position - frag_data.world_pos);
	vec3 r = reflect(v, normalize(frag_data.normal));
	float n_dot_v = clamp(dot(frag_data.normal, v), 0.0001, 1.0);
	vec3 specular_sample = de_gamma(textureLod(u_skybox_texture, r, frag_data.roughness * 10.0).rgb);
	vec3 fresnel_IBL = fresnel_schlick(n_dot_v, specular_sample, frag_data.metalness);
	
	vec3 IBL = specular_sample * (frag_data.metalness * frag_data.roughness);

	FragColor = vec4(IBL + final_color, 1.0);
}

\deferred_lightpass.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;

const float PI = 3.14159226;

uniform vec3 u_camera_position;

uniform vec2 u_camera_nearfar;
uniform sampler2D u_albedo_tex;
uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_depth_tex;

// Light uniforms
uniform int u_light_shadow_id;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform float u_light_max_dist;
uniform float u_light_intensities;
uniform vec3 u_light_direction;
uniform int u_light_type;
uniform vec2 u_screen_res;

uniform samplerCube u_skybox_texture;

// Spot light uniforms
uniform float u_light_cone_angle;
uniform float u_light_cone_decay;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;

in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

#include "depth_functions"
#include "frag_data"
#include "deferred_fragment_data"
#include "pbr"

void main()
{
	vec2 uv = gl_FragCoord.xy * u_screen_res.xy;

	sFragData frag_data = getDataOfFragment(uv);
	sFragVects light_vects = getVectsOfFragment(frag_data, u_light_pos, u_light_direction, u_light_max_dist, u_light_type);

	float shadow_compoment = 1.0;

	if (u_light_type == 2) { // Calculate if its in shadow if its not a point-light
		shadow_compoment = get_shadow_component(u_light_shadow_id, frag_data.world_pos);
	}

	// If its in shadow, skip the light contribution
	if (shadow_compoment == 0) {
		discard;
	}

	vec3 color = get_pbr_color(frag_data, light_vects);

	vec3 light_component = vec3(0.0);

	if (u_light_type == 2) { // Spot light
		if (light_vects.l_dot_d >= u_light_cone_angle) {
			// If the fragment to light direction is inside the angle of the spotlight
			light_component += (pow(light_vects.l_dot_d, u_light_cone_decay) * light_vects.n_dot_l * de_gamma(u_light_color)) * u_light_intensities;
		}
	} else { // For point light
		light_component += (light_vects.n_dot_l * de_gamma(u_light_color)) * u_light_intensities;
	}
	
	FragColor = vec4(color * light_component, 1.0);
	//FragColor = vec4(color, 1.0);
}

\ref_probe.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;

uniform vec3 u_camera_position;
uniform samplerCube u_skybox_texture;

out vec4 FragColor;

void main()
{
	vec3 V = normalize(v_world_position - u_camera_position);
	vec3 R = reflect(V, normalize(v_normal));
	FragColor = vec4(texture(u_skybox_texture, R).rgb, 1.0);
}

\skybox.fs
#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;

#include "hdr_tonemapping"

uniform vec3 u_camera_position;
uniform samplerCube u_texture;

out vec4 FragColor;

void main()
{
	vec3 V = normalize(v_world_position - u_camera_position);
	FragColor = vec4(de_gamma(texture(u_texture, V).rgb), 1.0);
	//FragColor = vec4(1.0);
}

\volumetric.fs
#version 330 core

in vec2 v_uv;
in mat4 v_viewprojection_inv;

uniform vec2 u_camera_nearfar;
uniform vec3 u_camera_position;

uniform sampler2D u_depth_tex;
uniform vec2 u_near_far;

// Ray properties
uniform float u_ray_max_len;
uniform int u_ray_sample_num;
uniform float u_air_density;

// Lights properties
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform int u_light_type[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform int u_num_lights;
// Spot light uniforms
uniform float u_light_cone_angle[MAX_LIGHT];
uniform float u_light_cone_decay[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_LIGHT];
uniform float u_shadow_bias;

layout(location = 0) out vec4 FragColor;

#include "depth_functions"
#include "hdr_tonemapping"

vec3 get_world_position_from_depth(const in vec2 uv, out float d) {
	d = texture2D(u_depth_tex, uv).x;	
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

vec3 compute_light_contibution(vec3 world_position) {
	vec3 light_component = vec3(0.0);
	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = 1.0;

		if (u_light_type[i] != 0) { // Calculate if its in shadow if its not a point-light
			shadow_compoment = get_shadow_component(u_light_shadow_id[i], world_position);
		}

		if (shadow_compoment == 0) {
			continue;
		}

		// Quadratic light attenuation
		float light_attenuation = 1.0;

		if (u_light_type[i] != 1) {
			light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - world_position);
			light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
			light_attenuation *= light_attenuation;
		}

		vec3 L = vec3(0.0);
		vec3 D = normalize(u_light_direction[i]);

		if (u_light_type[i] == 1) { // Directional light
			L = normalize(u_light_direction[i]);
		} else {	
			L = normalize(u_light_pos[i] - world_position);
		}
				
		float l_dot_d = dot(D, L);

		if (u_light_type[i] == 2) { // Spot light
			if (l_dot_d >= u_light_cone_angle[i]) {
				// If the fragment to light direction is inside the angle of the spotlight
				light_component += (pow(l_dot_d, u_light_cone_decay[i]) * de_gamma(u_light_color[i])) * u_light_intensities[i] * light_attenuation;
			}
		} else { // For point light & directional light
			light_component += (de_gamma(u_light_color[i])) * u_light_intensities[i] * light_attenuation;
		}
	}

	return light_component;
}

void main() {
	float depth = 0.0;
	vec3 world_pos = get_world_position_from_depth(v_uv, depth);

	// Linearize depth
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	depth = n * (depth + 1.0) / (f + n - depth * (f - n));

	if (depth >= 1.0) {
		// The sky, so skip!
		//FragColor = vec4(0.0);
		//return;
	}

	// Ray config
	vec3 ray_start = u_camera_position;
	vec3 ray_dir = (world_pos - ray_start);
	float ray_length = min(length(ray_dir), u_ray_max_len); // Set max ray distance
	ray_dir = normalize(ray_dir);
	float ray_step_distance = ray_length / u_ray_sample_num;
	vec3 ray_step = ray_dir * ray_step_distance;

	vec3 ray_curr_pos = ray_start;
	float curr_transparency = 1.0;
	vec3 color_result = vec3(0.0);
	for(int i = 0; i < u_ray_sample_num; i++) {
		vec3 light_contrib = compute_light_contibution(ray_curr_pos);

		color_result += light_contrib * curr_transparency * u_air_density * ray_step_distance;

		curr_transparency -= u_air_density * ray_step_distance;

		if (curr_transparency < 0.001) {
			break;
		}

		// Move forward the ray
		ray_curr_pos += ray_step;
	}

	FragColor = vec4(color_result * 10.0, 1.0 - curr_transparency);
} 


\comp_volumetric.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_volumetric;
uniform sampler2D u_color;
uniform int u_filter_size;

out vec4 FragColor;

vec4 get_blur_sample() {
	vec2 texel_size = 1.0 / vec2(textureSize(u_volumetric, 0).xy);
	vec4 result = vec4(0.0);

	for(int x = int(u_filter_size / -2); x < (u_filter_size / 2); x++) {
		for(int y = int(u_filter_size / -2); y < (u_filter_size / 2); y++) {
			vec2 offset = vec2(float(x), float(y)) * texel_size;
			result += texture(u_volumetric, v_uv + offset).rgba;
		}
	}

	return result / (u_filter_size * u_filter_size);
}

void main () {
	vec4 vol_sample = get_blur_sample();
	vec3 color_sample = texture(u_color, v_uv).rgb;
	FragColor = vec4(mix(color_sample, vol_sample.rgb, vol_sample.a), 1.0);
	FragColor = vec4(color_sample +  (vol_sample.rgb - vec3(vol_sample.a)), 1.0);
}


\deferred_decals.fs
#version 330 core

in mat4 v_viewprojection_inv;
in mat4 v_model_inv;

uniform vec2 u_iRes;
uniform sampler2D u_color_tex;
uniform sampler2D u_depth_tex;

layout(location = 0) out vec4 o_frag_albedo;


vec3 get_world_position_from_depth(const in vec2 uv) {
	float d = texture2D(u_depth_tex, uv).x;	
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

void main() {
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	vec3 world_pos = get_world_position_from_depth(uv);

	vec3 local_pos = (v_model_inv * vec4(world_pos, 1.0)).xyz;

	if( local_pos.x < -0.5 || local_pos.x > 0.5 ||
    	local_pos.y < -0.5 || local_pos.y > 0.5 ||
    	local_pos.z < -0.5 || local_pos.z > 0.5 )
		discard;

	vec2 decal_uv = local_pos.xz + vec2(0.5);

	vec4 decal_albedo = texture(u_color_tex, decal_uv);


	
	o_frag_albedo = decal_albedo;
}
\threshold_bloom.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_tex;
uniform float u_threshold;

out vec4 FragColor;

void main() {
	vec4 pixel_color = textureLod(u_color_tex, v_uv, 0);
	float pixel_luma = (pixel_color.r * 0.3) + (pixel_color.g * 0.59) + (pixel_color.b * 0.11);

	if (pixel_luma < u_threshold) {
		FragColor = vec4(0.0);
		return;
	}

	FragColor = pixel_color;
}

\bloom.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_tex;

uniform int u_bloom_steps_num;
uniform int u_max_step_LOD;
uniform int u_min_step;
uniform int u_max_LOD;

out vec4 FragColor;

const float TWO_PI = 6.28318530718;
const float E = 2.71828182846;
const float Spread = 4.0;
float gaussian(float x, float y)
{
    const float sigmaSqu = Spread * Spread;
    return (1.0 / sqrt(TWO_PI * sigmaSqu)) * pow(E, -((x * x) + (y * y)) / (2.0 * sigmaSqu));
}

// psudo Gaussian blur from: https://www.shadertoy.com/view/Xltfzj
vec3 Blur(vec2 uv, int LOD) {
    float pi2 = 6.28318530718; // Pi*2
    
    // GAUSSIAN BLUR SETTINGS
    float directions = 16.0;
    float quality = 6.0;
    float size = 1.5;
   
    vec2 radius = size/textureSize(u_color_tex, LOD).xy;
    
    // Normalized pixel coordinates (from 0 to 1)
    // Pixel colour
    vec3 Color = textureLod(u_color_tex, uv, LOD).rgb;
    
    // Blur calculations
    for( float d=0.0; d<pi2; d+=pi2/directions){
		for(float i=1.0/quality; i<=1.0; i+=1.0/quality) {
			Color += textureLod( u_color_tex, uv+vec2(cos(d),sin(d))*radius*i, LOD).rgb;		
        }
    }
    
    // Output to screen
    Color /= quality * directions - 15.0;
	return Color;
}




void main() {
	float level_step = max(u_max_step_LOD / u_bloom_steps_num, u_min_step);

	float currentLOD = 0.0;
	vec3 result = vec3(0.0);
	for(int i = 0; i < u_bloom_steps_num; i++) {
		//result += box_blur(v_uv, int(currentLOD)) * 1/pow(2,1 + u_bloom_steps_num - i);
		result += Blur(v_uv, int(currentLOD));
		currentLOD += level_step;
	}

	FragColor = vec4(result, 1.0);
}