//example of some shaders compiled
// Basic /  Base shaders
flat basic.vs flat.fs
shadow_flat basic.vs shadow_flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
// Phong
multi_phong basic.vs multi_phong.fs
single_phong basic.vs single_phong.fs
// Forward - PBR
forward_singlepass_pbr basic.vs forward_singlepass_pbr.fs
// Deferred -PBR
deferred_plane_opaque basic.vs deferred_plain_opaque.fs
deferred_plane_traslucent basic.vs deferred_plain_traslucent.fs
deferred_lightpass basic.vs deferred_lightpass.fs
deferred_pass quad.vs deferred_pass.fs
deferred_world_pos quad.vs deferred_world_pos.fs
// Render Passes & Effects
ao_pass quad.vs ao_pass.fs
uncharted_tonemapper quad.vs uncharted_tonemapping_pass.fs
blur quad.vs blur.fs

\depth_functions

const vec3 TILES_SIZES[MAX_SHADOWS] = vec3[](
	vec3(0.0, 0.5, 0.5), // Tile 0
	vec3(0.0, 0.0, 0.5), // 1
	vec3(0.5, 0.0, 0.5), // 2
	vec3(0.5, 0.25, 0.25), // 3
	vec3(0.75, 0.0, 0.25), // 4
	vec3(0.75, 0.25, 0.25), // 5
	vec3(0.75, 0.5, 0.25) // 6
);

float get_shadow_component(int light_id, vec3 world_pos) {
	vec4 frag_shadow_pos = u_shadow_vp[light_id] * vec4(world_pos, 1.0);
	//vec4 frag_shadow_pos =  vec4(v_world_position, 1.0);
	vec2 frag_shadow_uv = ((frag_shadow_pos.xy / frag_shadow_pos.w) * 0.5) + vec2(0.5); // ??

	if (frag_shadow_uv.x < 0.0 && frag_shadow_uv.x > 1.0 && frag_shadow_uv.y < 0.0 && frag_shadow_uv.y > 1.0) {
		return 0.0;
	}

	frag_shadow_uv.xy = TILES_SIZES[light_id].xy + (frag_shadow_uv.xy * TILES_SIZES[light_id].z);

	float frag_depth = (((frag_shadow_pos.z - u_shadow_bias) / frag_shadow_pos.w) * 0.5) + 0.5;
	float shadow_map_depth = texture(u_shadow_map, frag_shadow_uv).x;

	float shadow_compoment = 1.0f;
	if (shadow_map_depth < frag_depth && (frag_depth > 0.0 && frag_depth < 1.0)) {
		shadow_compoment = 0.0;
	}

	return shadow_compoment;
}

\normal_functions

mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {
  // get edge vectors of the pixel triangle
  vec3 dp1 = dFdx(p);
  vec3 dp2 = dFdy(p);
  vec2 duv1 = dFdx(uv);
  vec2 duv2 = dFdy(uv);

  // solve the linear system
  vec3 dp2perp = cross(dp2, N);
  vec3 dp1perp = cross(N, dp1);
  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

  // construct a scale-invariant frame 
  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));
  return mat3(normalize(T * invmax), normalize(B * invmax), N);
}

vec3 perturbNormal(vec3 N, vec3 world_pos, vec2 uv) {
	vec3 normal_pixel = texture2D(u_normal_tex, uv).xyz;
	// from 1 - 0 range to -1 - 1 range
	normal_pixel = normal_pixel * 255.0/127.0 - 128.0/127.0;
	mat3 TBN = cotangentFrame(N, world_pos, uv);
	return normalize(TBN * normal_pixel);
}

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;
out mat4 v_viewprojection_inv;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	v_viewprojection_inv = inverse(u_viewprojection);

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
uniform mat4 u_viewprojection;
out vec2 v_uv;
out mat4 v_viewprojection_inv;

void main()
{	
	v_uv = a_coord;
	v_viewprojection_inv = inverse(u_viewprojection);
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}

\shadow_flat.fs

#version 330 core

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_alpha_cutoff;

in vec2 v_uv;

out vec4 FragColor;

void main()
{
	if (texture(u_texture, v_uv).a < u_alpha_cutoff) {
		discard;
	}
	FragColor = u_color;
}

\multi_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

uniform float u_time;
uniform float u_alpha_cutoff;

// Light data
uniform vec3 u_ambient_light;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform int u_light_type;
uniform float u_light_max_dist;
uniform float u_light_intensities;
uniform int u_num_lights;

// Spot light uniforms
uniform float u_light_cone_angle;
uniform float u_light_cone_decay;
uniform vec3 u_light_direction;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;
uniform int u_light_id;

out vec4 FragColor;

#include "depth_functions"

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	float shadow_compoment = get_shadow_component(u_light_id, v_world_position);

	if (shadow_compoment == 0) {
		FragColor = vec4(color.rgb * u_ambient_light, 1.0);
		return;
	}

	vec3 L = vec3(0.0);
	vec3 D = normalize(u_light_direction);

	if (u_light_type == 1) { // Point light
		L = normalize(u_light_direction);
	} else {
		L = normalize(u_light_pos - v_world_position);
	}
		
	float n_dot_l = max(dot(L, N), 0.0);
	float l_dot_d = dot(D, L);

	// Quadratic light attenuation
	float light_attenuation = u_light_max_dist - length(u_light_pos - v_world_position);
	light_attenuation = max(light_attenuation / u_light_max_dist, 0.0); 
	light_attenuation *= light_attenuation;

	if (u_light_type == 2) { // Spot light
		if (l_dot_d >= u_light_cone_angle) {
			// If the fragment to light direction is inside the angle of the spotlight
			light_component += (pow(l_dot_d, u_light_cone_decay) * n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
		}
	} else { // For directional & spotlight
		light_component += (n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
	}
	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	color.rgb = color.rgb * (light_component + u_ambient_light + emmisive_comp) * occlusion_comp;

	FragColor = color;
}

\single_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

uniform float u_time;
uniform float u_alpha_cutoff;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

// Light data
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform int u_light_type[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_LIGHT];
uniform float u_shadow_bias;

// Spot light uniforms
uniform float u_light_cone_angle[MAX_LIGHT];
uniform float u_light_cone_decay[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];

out vec4 FragColor;
#include "depth_functions"

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	vec3 light_component = vec3(0.0);

	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = get_shadow_component(u_light_shadow_id[i], v_world_position);

		if (shadow_compoment == 0) {
			continue;
		}

		vec3 L = vec3(0.0);
		vec3 D = normalize(u_light_direction[i]);

		if (u_light_type[i] == 1) { // Directional light
			L = normalize(u_light_direction[i]);
		} else {
			L = normalize(u_light_pos[i] - v_world_position);
		}
		
		float n_dot_l = max(dot(L, N), 0.0);
		float l_dot_d = dot(D, L);

		// Quadratic light attenuation
		float light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - v_world_position);
		light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
		light_attenuation *= light_attenuation;

		if (u_light_type[i] == 2) { // Spot light
			if (l_dot_d >= u_light_cone_angle[i]) {
				// If the fragment to light direction is inside the angle of the spotlight
				light_component += (pow(l_dot_d, u_light_cone_decay[i]) * n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
			}
		} else if (u_light_type[i] == 1) { 
			light_component += (n_dot_l * u_light_color[i]) * u_light_intensities[i];
		} else { // For directional & spotlight
			light_component += (n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
		}
	}

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	FragColor = vec4(color.rgb * ((light_component + emmisive_comp) + (occlusion_comp * u_ambient_light)), 1.0);
}

\deferred_plain_opaque.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;
uniform int u_material_type;

uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 o_frag_albedo;
layout(location = 1) out vec4 o_frag_normal;
layout(location = 2) out vec4 o_frag_materials;
layout(location = 3) out vec4 o_emmisive_materials;

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	o_frag_albedo = color;
	vec3 text_N = texture( u_normal_tex, v_uv).rgb;
	vec3 N = vec3(0.0);
	if(length(text_N.rgb) == 0.0) {
		N = normalize(v_normal);
	} else {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	o_frag_normal = vec4(N * 0.5 + vec3(0.5), occlusion_comp);
	vec4 mats = texture( u_met_rough_tex, v_uv);
	if (u_material_type == 0) {
		o_frag_materials = vec4(mats.r, mats.g, 0.0, 0.0);
	} else {
		o_frag_materials = vec4(mats.g, mats.b, 0.0, 0.0);
	}
	o_emmisive_materials = vec4(emmisive_comp, 1.0);
}

\deferred_plain_traslucent.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;
uniform int u_material_type;

uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 o_frag_albedo;
layout(location = 1) out vec4 o_frag_normal;
layout(location = 2) out vec4 o_frag_materials;
layout(location = 3) out vec4 o_emmisive_materials;

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	o_frag_albedo = color;
	vec3 text_N = texture( u_normal_tex, v_uv).rgb;
	if(length(text_N.rgb) == 0.0) {
		o_frag_normal = vec4(normalize(v_normal), occlusion_comp);
	} else {
		o_frag_normal = vec4(perturbNormal(normalize(v_normal), v_world_position, v_uv), occlusion_comp);
	}
	
	vec4 mats = texture( u_met_rough_tex, v_uv);
	if (u_material_type == 0) {
		o_frag_materials = vec4(mats.r, mats.g, 0.0, 0.0);
	} else {
		o_frag_materials = vec4(mats.g, mats.b, 0.0, 0.0);
	}
	o_emmisive_materials = vec4(emmisive_comp, 1.0);
}

\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
uniform int u_linearize;
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	if (u_linearize == 1.0) {
		color = z;
	}
	FragColor = vec4(color);
}

\deferred_world_pos.fs

#version 330 core
uniform sampler2D u_depth_tex;

in vec2 u_camera_nearfar;
in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

vec3 get_world_position_from_depth() {
	float d = texture(u_depth_tex, v_uv).r;	
	vec4 clip = vec4(v_uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

void main()
{
	vec3 pos = get_world_position_from_depth();
	FragColor = vec4(pos, 1.0);
}

\brdf
float distribution_GGX(const in sFragData data, const in sFragVects vectors) {
	float alpha_squared = data.alpha * data.alpha;

	float f = ((vectors.n_dot_h * vectors.n_dot_h) * (alpha_squared - 1.0)) + 1.0;
	return alpha_squared / ((PI * f * f));
}

vec3 fresnel_schlick(const in float angle, const in vec3 f0) {
	float f = pow(1.0 - angle, 5.0);
	return f0 + (vec3(1.0) - f0) * f;
}

float GGX(const in float n_dot_v, const in float k) {
	return n_dot_v / (n_dot_v * (1.0 - k) + k);
}

float geometry_Smith(const in sFragData data, const in sFragVects vectors) {
	float k = pow(data.roughness + 1.0, 2.0) / 8.0;
	return GGX(vectors.n_dot_l, k) * GGX(vectors.n_dot_v, k);
}

vec3 specular_BRDF(const in sFragData data, const in sFragVects vectors) {
	float D = distribution_GGX(data, vectors);

	vec3 F = fresnel_schlick(vectors.n_dot_h, data.f0);

	float G = geometry_Smith(data, vectors);

	float normalization = (4.0 * vectors.n_dot_l * vectors.n_dot_v) + 0.001;

	return vec3(D * F * G) / normalization;
}

\pbr 

#include "brdf"

vec3 get_pbr_color(const in sFragData data, const in sFragVects vects) {
	vec3 diffuse_color = mix(data.albedo, vec3(0.0), data.metalness);

	vec3 specular = specular_BRDF(data, vects);
	vec3 diffuse = data.occlusion * diffuse_color / PI; // Lambertian BRDF cuz cheap

	return (specular + diffuse) * vects.attenuation;
}

\hdr_tonemapping

vec3 de_gamma(const in vec3 color) {
	return pow(color, vec3(2.2));
}

vec3 gamma(const in vec3 color) {
	return pow(color, vec3(1.0/2.2));
}

\frag_data

struct sFragData {
	// Material
	float roughness;
	float alpha;
	float metalness;
	vec3 f0;

	vec3 albedo;
	vec3 emmisive;

	float occlusion;

	vec3 normal;

	// Position
	vec3 world_pos;

	vec2 uv;
};

struct sFragVects {
	vec3 l;
	float n_dot_v;
	float n_dot_h;
	float n_dot_l;
	float l_dot_d;
	float l_dot_h;
	float v_dot_h;
	float attenuation;
};

\deferred_fragment_data
sFragVects getVectsOfFragment(const in sFragData mat, const in vec3 light_pos, const in vec3 light_direction, const in float light_max_dist, const in int light_type) {
	sFragVects vects;

	if (light_type == 1) { // Directional light
		vects.l = normalize(light_direction);
		vects.attenuation = 1.0; // No atenuation for the directional/sun/moon light
	} else {
		vects.l = normalize(light_pos - mat.world_pos);
		vects.attenuation = light_max_dist - length(mat.world_pos - light_pos);
		vects.attenuation = max(vects.attenuation / light_max_dist, 0.0); 
		vects.attenuation *= vects.attenuation;
	}
	
	vec3 D = normalize(light_direction);
	vec3 v = normalize(u_camera_position - mat.world_pos);
	vec3 half_v = normalize(v + vects.l);

	vects.l_dot_d = clamp(dot(D, vects.l), 0.0001, 1.0);
	vects.l_dot_h = clamp(dot(half_v, vects.l), 0.0001, 1.0);

	vects.n_dot_v = clamp(dot(mat.normal, v), 0.0001, 1.0);
	vects.n_dot_h = clamp(dot(mat.normal, half_v), 0.0001, 1.0);
	vects.n_dot_l = clamp(dot(mat.normal, vects.l), 0.0001, 1.0);

	return vects;
}

vec3 get_world_position_from_depth(const in vec2 uv) {
	float d = texture2D(u_depth_tex, uv).x;	
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

#include "hdr_tonemapping"

sFragData getDataOfFragment(const in vec2 uv) {
	sFragData mat;

	vec4 mrt = texture(u_met_rough_tex, uv);
	mat.roughness = mrt.g;
	mat.metalness = mrt.r;

	mat.albedo = de_gamma(texture(u_albedo_tex, uv).rgb);

	vec4 norm_occ = texture(u_normal_occ_tex, uv);
	mat.normal = normalize(norm_occ.rgb * 2.0 - 1.0);
	mat.occlusion = norm_occ.a;

	mat.world_pos = get_world_position_from_depth(uv);

	mat.f0 = mix(vec3(0.001), mat.albedo, mat.metalness);
	mat.alpha = mat.roughness * mat.roughness;

	return mat;
}


\forward_fragment_data

sFragVects getVectsOfFragment(const in sFragData mat, const in vec3 light_pos, const in vec3 light_direction, const in float light_max_dist, const in int light_type) {
	sFragVects vects;

	if (light_type == 1) { // Directional light
		vects.l = normalize(light_direction);
		vects.attenuation = 1.0; // No atenuation for the directional/sun/moon light
	} else {
		vects.l = normalize(light_pos - mat.world_pos);
		vects.attenuation = light_max_dist - length(mat.world_pos - light_pos);
		vects.attenuation = max(vects.attenuation / light_max_dist, 0.0); 
		vects.attenuation *= vects.attenuation;
	}
	
	vec3 D = normalize(light_direction);
	vec3 v = normalize(u_camera_position - mat.world_pos);
	vec3 half_v = normalize(v + vects.l);

	vects.l_dot_d = clamp(dot(D, vects.l), 0.0001, 1.0);
	vects.l_dot_h = clamp(dot(half_v, vects.l), 0.0001, 1.0);

	vects.n_dot_v = clamp(dot(mat.normal, v), 0.0001, 1.0);
	vects.n_dot_h = clamp(dot(mat.normal, half_v), 0.0001, 1.0);
	vects.n_dot_l = clamp(dot(mat.normal, vects.l), 0.0001, 1.0);

	return vects;
}

#include "hdr_tonemapping"

sFragData getDataOfFragment(const in vec2 uv) {
	sFragData mat;

	vec4 mrt = texture(u_met_rough_tex, uv);
	mat.roughness = mrt.r;
	mat.metalness = mrt.g;

	mat.albedo = de_gamma(u_color.rgb * texture(u_texture, uv).rgb);

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}
	mat.normal = N;

	mat.emmisive = texture( u_emmisive_tex, v_uv ).rgb;
	mat.occlusion = min(texture( u_occlusion_tex, v_uv ).r, texture(u_ambient_occlusion_tex, v_uv).r);

	mat.world_pos = v_world_position;

	mat.f0 = mix(vec3(0.001), mat.albedo, mat.metalness);
	mat.alpha = mat.roughness * mat.roughness;

	return mat;
}

\deferred_pass.fs

#version 330 core

const float PI = 3.14159226;

uniform vec2 u_camera_nearfar;
uniform vec3 u_camera_position;

// Light uniforms
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;
uniform int u_light_id;

uniform sampler2D u_albedo_tex;
uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_depth_tex;
uniform sampler2D u_ambient_occlusion_tex;

in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

#include "depth_functions"
#include "frag_data"
#include "deferred_fragment_data"
#include "pbr"


void main()
{
	sFragData frag_data = getDataOfFragment(v_uv);

	float occlusion = min(frag_data.occlusion, texture(u_ambient_occlusion_tex, v_uv).r);

	vec3 final_color = frag_data.albedo * (occlusion * (u_ambient_light));

	// Add emisivenes
	final_color += de_gamma(texture(u_emmisive_tex, v_uv).rgb); 

	// Only for directiona lights
	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = get_shadow_component(u_light_shadow_id[i], frag_data.world_pos);

		if (shadow_compoment == 0) {
			continue;
		}


		sFragVects light_vects = getVectsOfFragment(frag_data, u_light_pos[i], u_light_direction[i], u_light_max_dist[i], 1);

		vec3 color = get_pbr_color(frag_data, light_vects);
		
		vec3 light_component = (light_vects.n_dot_l * de_gamma(u_light_color[i])) * u_light_intensities[i];

		final_color += color * light_component;
	}

	//final_color = final_color;// * ();

	FragColor = vec4(final_color, 1.0);
}

\deferred_lightpass.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;

const float PI = 3.14159226;

uniform vec3 u_camera_position;

uniform vec2 u_camera_nearfar;
uniform sampler2D u_albedo_tex;
uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_depth_tex;

// Light uniforms
uniform int u_light_shadow_id;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform float u_light_max_dist;
uniform float u_light_intensities;
uniform vec3 u_light_direction;
uniform int u_light_type;
uniform vec2 u_screen_res;

// Spot light uniforms
uniform float u_light_cone_angle;
uniform float u_light_cone_decay;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;

in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

#include "depth_functions"
#include "frag_data"
#include "deferred_fragment_data"
#include "pbr"

void main()
{
	vec2 uv = gl_FragCoord.xy * u_screen_res.xy;

	sFragData frag_data = getDataOfFragment(uv);
	sFragVects light_vects = getVectsOfFragment(frag_data, u_light_pos, u_light_direction, u_light_max_dist, u_light_type);

	float shadow_compoment = 1.0;

	if (u_light_type != 1) { // Calculate if its in shadow if its not a point-light
		shadow_compoment = get_shadow_component(u_light_shadow_id, frag_data.world_pos);
	}

	// If its in shadow, skip the light contribution
	if (shadow_compoment == 0) {
		discard;
	}

	vec3 color = get_pbr_color(frag_data, light_vects);

	vec3 light_component = vec3(0.0);

	if (u_light_type == 2) { // Spot light
		if (light_vects.l_dot_d >= u_light_cone_angle) {
			// If the fragment to light direction is inside the angle of the spotlight
			light_component += (pow(light_vects.l_dot_d, u_light_cone_decay) * light_vects.n_dot_l * de_gamma(u_light_color)) * u_light_intensities;
		}
	} else { // For point light
		light_component += (light_vects.n_dot_l * de_gamma(u_light_color)) * u_light_intensities;
	}
	
	FragColor = vec4(color * light_component, 1.0);
}

\uncharted_tonemapping_pass.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_albedo_tex;

layout(location = 0) out vec4 o_color;

#include "hdr_tonemapping"

// Source http://filmicworlds.com/blog/filmic-tonemapping-operators/
const float A = 0.15;
const float B = 0.50;
const float C = 0.10;
const float D = 0.20;
const float E = 0.02;
const float F = 0.30;
const float W = 11.2;

vec3 Uncharted2TonemapPartial(vec3 x) {
   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

void main() {
	vec3 tonemapped_color = Uncharted2TonemapPartial(texture(u_albedo_tex, v_uv).rgb * 2.0);

	vec3 W = vec3(11.2f);
    vec3 white_scale = vec3(1.0f) / Uncharted2TonemapPartial(W);

	o_color = vec4(gamma(tonemapped_color * white_scale), 1.0);
}

\perception_tonemapping_pass.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_albedo_tex;

layout(location = 0) out vec4 o_color;

#include "hdr_tonemapping"

// Source http://filmicworlds.com/blog/filmic-tonemapping-operators/
const float A = 0.15;
const float B = 0.50;
const float C = 0.10;
const float D = 0.20;
const float E = 0.02;
const float F = 0.30;
const float W = 11.2;

vec3 Uncharted2TonemapPartial(vec3 x) {
   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

void main() {
	vec3 tonemapped_color = Uncharted2TonemapPartial(texture(u_albedo_tex, v_uv).rgb * 2.0);

	vec3 W = vec3(11.2f);
    vec3 white_scale = vec3(1.0f) / Uncharted2TonemapPartial(W);

	o_color = vec4(gamma(tonemapped_color * white_scale, 1.0);
}

\ao_pass.fs

#version 330 core

const float PI = 3.14159226;

uniform vec2 u_camera_nearfar;
uniform vec3 u_camera_position;

uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_depth_tex;
uniform sampler2D u_noise_tex;

uniform float u_ao_radius;

uniform vec2 u_noise_scale;

uniform vec2 u_near_far;

uniform mat4 u_viewprojection;
uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_inv_projection;

const int SAMPLE_SIZE = 64;
uniform vec3 u_random_point[SAMPLE_SIZE];

in vec2 v_uv;
in mat4 v_viewprojection_inv;

layout(location = 0) out vec3 o_frag_ao;


vec3 get_view_position_from_depth(vec2 uv) {
	float d = texture(u_depth_tex, uv).r;
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = u_inv_projection * clip;

	return world_pos.xyz / world_pos.w;
}

void main() {
	float sample_depth = texture(u_depth_tex, v_uv).r;	

	// Discard if its too far away/ or is sky
	if (sample_depth >= 1.0) {
		o_frag_ao = vec3(1.0);
		return;
	}

	vec3 frag_view_pos = get_view_position_from_depth(v_uv);

	vec3 normal = texture(u_normal_occ_tex, v_uv).rgb;
	normal = normalize(normal.rgb * 2.0 - 1.0);

	// Set normal on viewspace
	normal = (u_view * vec4(normal, 0.0)).xyz;

	// Create TBN matrix
	vec3 random_vec = (vec3(texture(u_noise_tex, v_uv * u_noise_scale).xy * 2.0 - 1.0, 0.0));
	vec3 tangent = normalize(random_vec - normal * dot(random_vec, normal));
	vec3 bitangent = (cross(normal, tangent));
	mat3 rot_mat = mat3(tangent, bitangent, normal);

	float occlusion = 0.0;
	 vec3 rebuild_sample_pos = vec3(0.0);
	for(int i = 0; i < SAMPLE_SIZE; i++) {
		vec3 sample_point = (frag_view_pos) + (normalize(rot_mat * u_random_point[i]) * u_ao_radius);

		// Bias
		sample_point += normal * 0.5;

		vec4 sample_ndc = u_projection * vec4(sample_point, 1.0);
		vec2 sample_uv = (sample_ndc.xy / sample_ndc.w) * 0.5 + 0.5;

		if (sample_uv.x > 1.0 || sample_uv.y > 1.0 || sample_uv.x < 0.0 || sample_uv.y < 0.0) {
			continue;
		}

		rebuild_sample_pos = get_view_position_from_depth(sample_uv);

		if (rebuild_sample_pos.z >= sample_point.z && abs(rebuild_sample_pos.z - frag_view_pos.z) <= u_ao_radius) { 
			occlusion += 1.0;
		}

	}
	
	o_frag_ao = vec3(1.0 - (occlusion / float(SAMPLE_SIZE)));
	// Enhance contrast
	o_frag_ao = o_frag_ao * o_frag_ao;
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}


\blur.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_to_blur_tex;

layout(location = 0) out vec3 o_frag_blur;

const float filter_size = 10.0;

void main() {
	vec2 texel_size = 1.0 / vec2(textureSize(u_to_blur_tex, 0));
	vec3 result = vec3(0.0);

	for(int x = int(filter_size / -2); x < (filter_size / 2); x++) {
		for(int y = int(filter_size / -2); y < (filter_size / 2); y++) {
			vec2 offset = vec2(float(x), float(y)) * texel_size;
			result += texture(u_to_blur_tex, v_uv + offset).rgb;
		}
	}

	o_frag_blur = result / (filter_size * filter_size);
}



\forward_singlepass_pbr.fs

#version 330 core

const float PI = 3.14159226;

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

uniform float u_time;
uniform float u_alpha_cutoff;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;
uniform sampler2D u_ambient_occlusion_tex;

uniform vec3 u_camera_position;

// Light data
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform int u_light_type[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_LIGHT];
uniform float u_shadow_bias;

// Spot light uniforms
uniform float u_light_cone_angle[MAX_LIGHT];
uniform float u_light_cone_decay[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];

out vec4 FragColor;
#include "depth_functions"
#include "normal_functions"
#include "frag_data"
#include "forward_fragment_data"
#include "pbr"

void main()
{
	vec4 color = texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	// Load fragment
	sFragData frag_data = getDataOfFragment(v_uv);

	vec3 final_color = frag_data.albedo * (frag_data.occlusion * (u_ambient_light));
	vec3 light_component = vec3(0.0);
	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = 1.0;

		if (u_light_type[i] != 1) { // Calculate if its in shadow if its not a point-light
			shadow_compoment = get_shadow_component(i, frag_data.world_pos);
		}

		if (shadow_compoment == 0) {
			continue;
		}

		sFragVects light_vects = getVectsOfFragment(frag_data, u_light_pos[i], u_light_direction[i], u_light_max_dist[i], u_light_type[i]);

		// Quadratic light attenuation
		float light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - v_world_position);
		light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
		light_attenuation *= light_attenuation;

		if (u_light_type[i] == 2) { // Spot light
			if (light_vects.l_dot_d >= u_light_cone_angle[i]) {
				// If the fragment to light direction is inside the angle of the spotlight
				light_component += (pow(light_vects.l_dot_d, u_light_cone_decay[i]) * light_vects.n_dot_l * de_gamma(u_light_color[i])) * u_light_intensities[i];
			}
		} else { // For point light
			light_component += (light_vects.n_dot_l * de_gamma(u_light_color[i])) * u_light_intensities[i];
		}
		final_color += light_component * get_pbr_color(frag_data, light_vects);
	}

	FragColor = vec4(final_color, 1.0);
}