//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
multi_phong basic.vs multi_phong.fs
single_phong basic.vs single_phong.fs

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}

\multi_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

uniform float u_time;
uniform float u_alpha_cutoff;

// Light data
uniform vec3 u_ambient_light;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform int u_light_type;
uniform float u_light_max_dist;
uniform float u_light_intensities;
uniform int u_num_lights;

// Spot light uniforms
uniform float u_light_cone_angle;
uniform float u_light_cone_decay;
uniform vec3 u_light_direction;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;
uniform int u_light_id;

out vec4 FragColor;

const vec3 TILES_SIZES[MAX_SHADOWS] = vec3[](
	vec3(0.0, 0.5, 0.5), // Tile 0
	vec3(0.0, 0.0, 0.5), // 1
	vec3(0.5, 0.0, 0.25), // 2
	vec3(0.5, 0.25, 0.25), // 3
	vec3(0.75, 0.0, 0.25), // 4
	vec3(0.75, 0.25, 0.25), // 5
	vec3(0.75, 0.5, 0.25) // 6
);

float get_shadow_component(int light_id) {
	vec4 frag_shadow_pos = u_shadow_vp[light_id] * vec4(v_world_position, 1.0);
	//vec4 frag_shadow_pos =  vec4(v_world_position, 1.0);
	vec2 frag_shadow_uv = ((frag_shadow_pos.xy / frag_shadow_pos.w) * 0.5) + vec2(0.5); // ??

	if (frag_shadow_uv.x < 0.0 && frag_shadow_uv.x > 1.0 && frag_shadow_uv.y < 0.0 && frag_shadow_uv.y > 1.0) {
		return 0.0;
	}

	frag_shadow_uv.xy = TILES_SIZES[light_id].xy + (frag_shadow_uv.xy * TILES_SIZES[light_id].z);

	float frag_depth = (((frag_shadow_pos.z - u_shadow_bias) / frag_shadow_pos.w) * 0.5) + 0.5;
	float shadow_map_depth = texture(u_shadow_map, frag_shadow_uv).x;

	float shadow_compoment = 1.0f;
	if (shadow_map_depth < frag_depth && (frag_depth > 0.0 && frag_depth < 1.0)) {
		shadow_compoment = 0.0;
	}

	return shadow_compoment;
} 


mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {
  // get edge vectors of the pixel triangle
  vec3 dp1 = dFdx(p);
  vec3 dp2 = dFdy(p);
  vec2 duv1 = dFdx(uv);
  vec2 duv2 = dFdy(uv);

  // solve the linear system
  vec3 dp2perp = cross(dp2, N);
  vec3 dp1perp = cross(N, dp1);
  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

  // construct a scale-invariant frame 
  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));
  return mat3(normalize(T * invmax), normalize(B * invmax), N);
}

vec3 perturbNormal(vec3 N, vec3 world_pos, vec2 uv) {
	vec3 normal_pixel = texture2D(u_normal_tex, uv).xyz;
	// from 1 - 0 range to -1 - 1 range
	normal_pixel = normal_pixel * 255.0/127.0 - 128.0/127.0;
	mat3 TBN = cotangentFrame(N, world_pos, uv);
	return normalize(TBN * normal_pixel);
}

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 N = perturbNormal(normalize(v_normal), v_world_position, v_uv);

	float shadow_compoment = get_shadow_component(u_light_id);

	if (shadow_compoment == 0) {
		FragColor = vec4(color.rgb * u_ambient_light, 1.0);
		return;
	}

	vec3 L = vec3(0.0);
	vec3 D = normalize(u_light_direction);

	if (u_light_type == 1) { // Point light
		L = normalize(u_light_direction);
	} else {
		L = normalize(u_light_pos - v_world_position);
	}
		
	float n_dot_l = max(dot(L, N), 0.0);
	float l_dot_d = dot(D, L);

	// Quadratic light attenuation
	float light_attenuation = u_light_max_dist - length(u_light_pos - v_world_position);
	light_attenuation = max(light_attenuation / u_light_max_dist, 0.0); 
	light_attenuation *= light_attenuation;

	if (u_light_type == 2) { // Spot light
		if (l_dot_d >= u_light_cone_angle) {
			// If the fragment to light direction is inside the angle of the spotlight
			light_component += (pow(l_dot_d, u_light_cone_decay) * n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
		}
	} else { // For directional & spotlight
		light_component += (n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
	}
	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	color.rgb = color.rgb * (light_component + u_ambient_light + emmisive_comp) * occlusion_comp;

	FragColor = color;
}

\single_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

uniform float u_time;
uniform float u_alpha_cutoff;

// Light data
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform int u_light_type[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_LIGHT];
uniform float u_shadow_bias;

// Spot light uniforms
uniform float u_light_cone_angle[MAX_LIGHT];
uniform float u_light_cone_decay[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];

out vec4 FragColor;

const vec3 TILES_SIZES[7] = vec3[](
	vec3(0.0, 0.5, 0.5), // Tile 0
	vec3(0.0, 0.0, 0.5), // 1
	vec3(0.5, 0.0, 0.25), // 2
	vec3(0.5, 0.25, 0.25), // 3
	vec3(0.75, 0.0, 0.25), // 4
	vec3(0.75, 0.25, 0.25), // 5
	vec3(0.75, 0.5, 0.25) // 6
);

float get_shadow_component(int light_id) {
	vec4 frag_shadow_pos = u_shadow_vp[light_id] * vec4(v_world_position, 1.0);
	//vec4 frag_shadow_pos =  vec4(v_world_position, 1.0);
	vec2 frag_shadow_uv = ((frag_shadow_pos.xy / frag_shadow_pos.w) * 0.5) + vec2(0.5); // ??

	if (frag_shadow_uv.x < 0.0 && frag_shadow_uv.x > 1.0 && frag_shadow_uv.y < 0.0 && frag_shadow_uv.y > 1.0) {
		return 0.0;
	}

	frag_shadow_uv.xy = TILES_SIZES[light_id].xy + (frag_shadow_uv.xy * TILES_SIZES[light_id].z);

	float frag_depth = (((frag_shadow_pos.z - u_shadow_bias) / frag_shadow_pos.w) * 0.5) + 0.5;
	float shadow_map_depth = texture(u_shadow_map, frag_shadow_uv).x;

	float shadow_compoment = 1.0f;
	if (shadow_map_depth < frag_depth && (frag_depth > 0.0 && frag_depth < 1.0)) {
		shadow_compoment = 0.0;
	}

	return shadow_compoment;
}

mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {
  // get edge vectors of the pixel triangle
  vec3 dp1 = dFdx(p);
  vec3 dp2 = dFdy(p);
  vec2 duv1 = dFdx(uv);
  vec2 duv2 = dFdy(uv);

  // solve the linear system
  vec3 dp2perp = cross(dp2, N);
  vec3 dp1perp = cross(N, dp1);
  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

  // construct a scale-invariant frame 
  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));
  return mat3(normalize(T * invmax), normalize(B * invmax), N);
}

vec3 perturbNormal(vec3 N, vec3 world_pos, vec2 uv) {
	vec3 normal_pixel = texture2D(u_normal_tex, uv).xyz;
	// from 1 - 0 range to -1 - 1 range
	normal_pixel = normal_pixel * 255.0/127.0 - 128.0/127.0;
	mat3 TBN = cotangentFrame(N, world_pos, uv);
	return normalize(TBN * normal_pixel);
}

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 N = perturbNormal(normalize(v_normal), v_world_position, v_uv);

	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = get_shadow_component(i);

		if (shadow_compoment == 0) {
			continue;
		}

		vec3 L = vec3(0.0);
		vec3 D = normalize(u_light_direction[i]);

		if (u_light_type[i] == 1) { // Point light
			L = normalize(u_light_direction[i]);
		} else {
			L = normalize(u_light_pos[i] - v_world_position);
		}
		
		float n_dot_l = max(dot(L, N), 0.0);
		float l_dot_d = dot(D, L);
		// Quadratic light attenuation
		float light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - v_world_position);
		light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
		light_attenuation *= light_attenuation;

		if (u_light_type[i] == 2) { // Spot light
			if (l_dot_d >= u_light_cone_angle[i]) {
				// If the fragment to light direction is inside the angle of the spotlight
				light_component += (pow(l_dot_d, u_light_cone_decay[i]) * n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
			}
		} else { // For directional & spotlight
			light_component += (n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
		}
	}

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	color.rgb = color.rgb * ((light_component + emmisive_comp) + (occlusion_comp * u_ambient_light));

	FragColor = color;
}

\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	FragColor = vec4(color);
}

\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}