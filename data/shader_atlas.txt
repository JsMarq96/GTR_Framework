//example of some shaders compiled
flat basic.vs flat.fs
shadow_flat basic.vs shadow_flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
multi_phong basic.vs multi_phong.fs
single_phong basic.vs single_phong.fs
deferred_plane_opaque basic.vs deferred_plain_opaque.fs
deferred_plane_traslucent basic.vs deferred_plain_traslucent.fs
deferred_lightpass basic.vs deferred_lightpass.fs
deferred_pass quad.vs deferred_pass.fs
deferred_world_pos quad.vs deferred_world_pos.fs

\depth_functions

const vec3 TILES_SIZES[MAX_SHADOWS] = vec3[](
	vec3(0.0, 0.5, 0.5), // Tile 0
	vec3(0.0, 0.0, 0.5), // 1
	vec3(0.5, 0.0, 0.5), // 2
	vec3(0.5, 0.25, 0.25), // 3
	vec3(0.75, 0.0, 0.25), // 4
	vec3(0.75, 0.25, 0.25), // 5
	vec3(0.75, 0.5, 0.25) // 6
);

float get_shadow_component(int light_id, vec3 world_pos) {
	vec4 frag_shadow_pos = u_shadow_vp[light_id] * vec4(world_pos, 1.0);
	//vec4 frag_shadow_pos =  vec4(v_world_position, 1.0);
	vec2 frag_shadow_uv = ((frag_shadow_pos.xy / frag_shadow_pos.w) * 0.5) + vec2(0.5); // ??

	if (frag_shadow_uv.x < 0.0 && frag_shadow_uv.x > 1.0 && frag_shadow_uv.y < 0.0 && frag_shadow_uv.y > 1.0) {
		return 0.0;
	}

	frag_shadow_uv.xy = TILES_SIZES[light_id].xy + (frag_shadow_uv.xy * TILES_SIZES[light_id].z);

	float frag_depth = (((frag_shadow_pos.z - u_shadow_bias) / frag_shadow_pos.w) * 0.5) + 0.5;
	float shadow_map_depth = texture(u_shadow_map, frag_shadow_uv).x;

	float shadow_compoment = 1.0f;
	if (shadow_map_depth < frag_depth && (frag_depth > 0.0 && frag_depth < 1.0)) {
		shadow_compoment = 0.0;
	}

	return shadow_compoment;
}

\normal_functions

mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {
  // get edge vectors of the pixel triangle
  vec3 dp1 = dFdx(p);
  vec3 dp2 = dFdy(p);
  vec2 duv1 = dFdx(uv);
  vec2 duv2 = dFdy(uv);

  // solve the linear system
  vec3 dp2perp = cross(dp2, N);
  vec3 dp1perp = cross(N, dp1);
  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

  // construct a scale-invariant frame 
  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));
  return mat3(normalize(T * invmax), normalize(B * invmax), N);
}

vec3 perturbNormal(vec3 N, vec3 world_pos, vec2 uv) {
	vec3 normal_pixel = texture2D(u_normal_tex, uv).xyz;
	// from 1 - 0 range to -1 - 1 range
	normal_pixel = normal_pixel * 255.0/127.0 - 128.0/127.0;
	mat3 TBN = cotangentFrame(N, world_pos, uv);
	return normalize(TBN * normal_pixel);
}

\fragment_materials

struct sFragmentMaterial {
	vec3 albedo;
	vec3 normal;
	float alpha;
	vec3 emmisive;
	float metallic;
	float roughnes;
	float occlusion;
};

#include "normal_functions"

sFragmentMaterial get_fragment_material(vec2 uv) {
	vec4 color = texture(u_texture, uv).rgba;
	vec4 met_rough = texture(u_met_rough_tex, uv).rgba;
	vec3 n = texture(u_normal_tex, uv).rgb;

	sFragmentMaterial frag_mat;
	frag_mat.albedo = color.rgb * u_color.rgb;
	frag_mat.alpha = color.a;
	frag_mat.normal = normalize(v_normal);
	frag_mat.emmisive = texture(u_emmisive_tex, uv).rgb;
	frag_mat.occlusion = texture(u_occlusion_tex, uv).r;
	frag_mat.metallic = met_rough.r;
	frag_mat.roughnes = met_rough.g;

	if (length(n) > 0.0) { // If normal is enabled
		frag_mat.normal = texture2D(u_normal_tex, uv).xyz;	
	}

	return frag_mat;
}

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;
out mat4 v_viewprojection_inv;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	v_viewprojection_inv = inverse(u_viewprojection);

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
uniform mat4 u_viewprojection;
out vec2 v_uv;
out mat4 v_viewprojection_inv;

void main()
{	
	v_uv = a_coord;
	v_viewprojection_inv = inverse(u_viewprojection);
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}

\shadow_flat.fs

#version 330 core

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_alpha_cutoff;

in vec2 v_uv;

out vec4 FragColor;

void main()
{
	if (texture(u_texture, v_uv).a < u_alpha_cutoff) {
		discard;
	}
	FragColor = u_color;
}

\multi_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

uniform float u_time;
uniform float u_alpha_cutoff;

// Light data
uniform vec3 u_ambient_light;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform int u_light_type;
uniform float u_light_max_dist;
uniform float u_light_intensities;
uniform int u_num_lights;

// Spot light uniforms
uniform float u_light_cone_angle;
uniform float u_light_cone_decay;
uniform vec3 u_light_direction;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;
uniform int u_light_id;

out vec4 FragColor;

#include "depth_functions"

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	float shadow_compoment = get_shadow_component(u_light_id, v_world_position);

	if (shadow_compoment == 0) {
		FragColor = vec4(color.rgb * u_ambient_light, 1.0);
		return;
	}

	vec3 L = vec3(0.0);
	vec3 D = normalize(u_light_direction);

	if (u_light_type == 1) { // Point light
		L = normalize(u_light_direction);
	} else {
		L = normalize(u_light_pos - v_world_position);
	}
		
	float n_dot_l = max(dot(L, N), 0.0);
	float l_dot_d = dot(D, L);

	// Quadratic light attenuation
	float light_attenuation = u_light_max_dist - length(u_light_pos - v_world_position);
	light_attenuation = max(light_attenuation / u_light_max_dist, 0.0); 
	light_attenuation *= light_attenuation;

	if (u_light_type == 2) { // Spot light
		if (l_dot_d >= u_light_cone_angle) {
			// If the fragment to light direction is inside the angle of the spotlight
			light_component += (pow(l_dot_d, u_light_cone_decay) * n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
		}
	} else { // For directional & spotlight
		light_component += (n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
	}
	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	color.rgb = color.rgb * (light_component + u_ambient_light + emmisive_comp) * occlusion_comp;

	FragColor = color;
}

\single_phong.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

uniform float u_time;
uniform float u_alpha_cutoff;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

// Light data
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform int u_light_type[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_LIGHT];
uniform float u_shadow_bias;

// Spot light uniforms
uniform float u_light_cone_angle[MAX_LIGHT];
uniform float u_light_cone_decay[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];

out vec4 FragColor;
#include "depth_functions"

#include "fragment_materials"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);
	if (length(texture( u_normal_tex, v_uv ).rgb) > 0.0) {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	vec3 light_component = vec3(0.0);

	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = get_shadow_component(u_light_shadow_id[i], v_world_position);

		if (shadow_compoment == 0) {
			continue;
		}

		vec3 L = vec3(0.0);
		vec3 D = normalize(u_light_direction[i]);

		if (u_light_type[i] == 1) { // Directional light
			L = normalize(u_light_direction[i]);
		} else {
			L = normalize(u_light_pos[i] - v_world_position);
		}
		
		float n_dot_l = max(dot(L, N), 0.0);
		float l_dot_d = dot(D, L);

		// Quadratic light attenuation
		float light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - v_world_position);
		light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
		light_attenuation *= light_attenuation;

		if (u_light_type[i] == 2) { // Spot light
			if (l_dot_d >= u_light_cone_angle[i]) {
				// If the fragment to light direction is inside the angle of the spotlight
				light_component += (pow(l_dot_d, u_light_cone_decay[i]) * n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
			}
		} else if (u_light_type[i] == 1) { 
			light_component += (n_dot_l * u_light_color[i]) * u_light_intensities[i];
		} else { // For directional & spotlight
			light_component += (n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
		}
	}

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	FragColor = vec4(color.rgb * ((light_component + emmisive_comp) + (occlusion_comp * u_ambient_light)), 1.0);
}

\deferred_plain_opaque.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 o_frag_albedo;
layout(location = 1) out vec4 o_frag_normal;
layout(location = 2) out vec4 o_frag_materials;
layout(location = 3) out vec3 o_emmisive_materials;

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	o_frag_albedo = color;
	vec3 text_N = texture( u_normal_tex, v_uv).rgb;
	vec3 N = vec3(0.0);
	if(length(text_N.rgb) == 0.0) {
		N = normalize(v_normal);
	} else {
		N = perturbNormal(normalize(v_normal), v_world_position, v_uv);
	}

	o_frag_normal = vec4(N * 0.5 + vec3(0.5), occlusion_comp);
	o_frag_materials = vec4(texture( u_met_rough_tex, v_uv).rg, 0.0, 0.0);
	o_emmisive_materials = texture(u_emmisive_tex, v_uv).rgb;
}

\deferred_plain_traslucent.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec2 v_frag_shadow_uv;

// Material data
uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emmisive_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_normal_tex;
uniform sampler2D u_occlusion_tex;

uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 o_frag_albedo;
layout(location = 1) out vec4 o_frag_normal;
layout(location = 2) out vec4 o_frag_materials;
layout(location = 3) out vec3 o_emmisive_materials;

#include "normal_functions"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light_component = vec3(0.0);

	vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;
	float occlusion_comp = texture( u_occlusion_tex, v_uv ).r;

	o_frag_albedo = color;
	vec3 text_N = texture( u_normal_tex, v_uv).rgb;
	if(length(text_N.rgb) == 0.0) {
		o_frag_normal = vec4(normalize(v_normal), occlusion_comp);
	} else {
		o_frag_normal = vec4(perturbNormal(normalize(v_normal), v_world_position, v_uv), occlusion_comp);
	}
	
	o_frag_materials = vec4(texture( u_met_rough_tex, v_uv).rg, 0.0, 0.0);
	o_emmisive_materials = texture(u_emmisive_tex, v_uv).rgb;
}

\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
uniform int u_linearize;
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	if (u_linearize == 1.0) {
		color = z;
	}
	FragColor = vec4(color);
}

\deferred_world_pos.fs

#version 330 core
uniform sampler2D u_depth_tex;

in vec2 u_camera_nearfar;
in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

vec3 get_world_position_from_depth() {
	float d = texture2D(u_depth_tex, v_uv).x;	
	vec4 clip = vec4(v_uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

void main()
{
	vec3 pos = get_world_position_from_depth();
	FragColor = vec4(pos, 1.0);
}

\deferred_pass.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_albedo_tex;
uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_depth_tex;

// Light uniforms
uniform vec3 u_ambient_light;
const int MAX_LIGHT = 7;
uniform int u_light_shadow_id[MAX_LIGHT];
uniform vec3 u_light_pos[MAX_LIGHT];
uniform vec3 u_light_color[MAX_LIGHT];
uniform float u_light_max_dist[MAX_LIGHT];
uniform float u_light_intensities[MAX_LIGHT];
uniform vec3 u_light_direction[MAX_LIGHT];
uniform int u_num_lights;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;
uniform int u_light_id;

in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

#include "depth_functions"

vec3 get_world_position_from_depth() {
	float d = texture2D(u_depth_tex, v_uv).x;	
	vec4 clip = vec4(v_uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

void main()
{
	vec3 world_pos = get_world_position_from_depth();

	vec4 color = texture( u_albedo_tex, v_uv );
	vec4 normal_occ = texture2D(u_normal_occ_tex, v_uv);
	float occlusion_comp = normal_occ.a;

	vec3 light_component = vec3(0.0);

	vec3 N = normal_occ.rgb * 2.0 - 1.0;

	// Only for directiona lights
	for(int i = 0; i < MAX_LIGHT; i++) {
		if (i >= u_num_lights) {
			continue;
		}

		float shadow_compoment = get_shadow_component(u_light_shadow_id[i], world_pos);

		if (shadow_compoment == 0) {
			continue;
		}

		vec3 L =  normalize(u_light_direction[i]);
		
		float n_dot_l = max(dot(L, N), 0.0);
		// Quadratic light attenuation
		float light_attenuation = u_light_max_dist[i] - length(u_light_pos[i] - world_pos);
		light_attenuation = max(light_attenuation / u_light_max_dist[i], 0.0); 
		light_attenuation *= light_attenuation;

		
		light_component += (n_dot_l * u_light_color[i]) * light_attenuation * u_light_intensities[i];
	}

	//vec3 emmisive_comp = texture( u_emmisive_tex, v_uv ).rgb;

	//color.rgb = color.rgb * ((light_component + emmisive_comp) + (occlusion_comp * u_ambient_light));
	color.rgb = color.rgb * ((light_component) + (occlusion_comp * u_ambient_light));

	FragColor = color;
}

\deferred_lightpass.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;

uniform vec2 u_camera_nearfar;
uniform sampler2D u_albedo_tex;
uniform sampler2D u_normal_occ_tex;
uniform sampler2D u_met_rough_tex;
uniform sampler2D u_depth_tex;

// Light uniforms
uniform int u_light_shadow_id;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform float u_light_max_dist;
uniform float u_light_intensities;
uniform vec3 u_light_direction;
uniform int u_light_type;
uniform vec2 u_screen_res;

// Spot light uniforms
uniform float u_light_cone_angle;
uniform float u_light_cone_decay;

// Shadows uniforms
const int MAX_SHADOWS = 7;
uniform sampler2D u_shadow_map;
uniform mat4 u_shadow_vp[MAX_SHADOWS];
uniform float u_shadow_bias;

in vec2 v_uv;
in mat4 v_viewprojection_inv;

out vec4 FragColor;

#include "depth_functions"

vec3 get_world_position_from_depth(vec2 uv) {
	float d = texture2D(u_depth_tex, uv).x;	
	vec4 clip = vec4(uv * 2.0 - 1.0, d * 2.0 - 1.0, 1.0);
	vec4 world_pos = v_viewprojection_inv * clip;

	return world_pos.xyz / world_pos.w;
}

void main()
{
	vec2 uv = gl_FragCoord.xy * u_screen_res.xy;
	vec3 world_pos = get_world_position_from_depth(uv);

	vec4 color = texture( u_albedo_tex, uv );
	vec4 normal_occ = texture2D(u_normal_occ_tex, uv);
	float occlusion_comp = normal_occ.a;

	vec3 light_component = vec3(0.0);

	vec3 N = normalize(normal_occ.rgb * 2.0 - 1.0);

	float shadow_compoment = 1.0;

	if (u_light_type != 1) {
		shadow_compoment = get_shadow_component(u_light_shadow_id, world_pos);
	}

	if (shadow_compoment == 0) {
		discard;
	}

	// Quadratic light attenuation
	float light_attenuation = 0.0;

	vec3 L = vec3(0.0);
	if (u_light_type == 1) { // Directional light
		L = normalize(u_light_pos);
		light_attenuation = 1.0;
	} else {
		L = normalize(u_light_pos - world_pos);
		light_attenuation = u_light_max_dist - length(world_pos - u_light_pos);
		light_attenuation = max(light_attenuation / u_light_max_dist, 0.0); 
		light_attenuation *= light_attenuation;
	}
	
	vec3 D = normalize(u_light_direction);
	float n_dot_l = max(dot(L, N), 0.0);
	float l_dot_d = dot(D, L);

	if (u_light_type == 2) { // Spot light
		if (l_dot_d >= u_light_cone_angle) {
			// If the fragment to light direction is inside the angle of the spotlight
			light_component += (pow(l_dot_d, u_light_cone_decay) * n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
			//light_component = u_light_color;
		}
	} else { // For directional & point
		light_component += (n_dot_l * u_light_color) * light_attenuation * u_light_intensities;
	}
	
	//light_component += (n_dot_l * u_light_color) * light_attenuation;

	//color.rgb = color.rgb * ((light_component + emmisive_comp) + (occlusion_comp * u_ambient_light));
	//color.rgb =  color.rgb * light_component;
	//FragColor = vec4(vec3(1.0, color_d, color_d),  1.0);
	FragColor = vec4(color.rgb * light_component, 1.0);
	//FragColor = color;
}

\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}